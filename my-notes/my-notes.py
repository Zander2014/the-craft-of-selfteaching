第一天
    <本书>
做了什么：
    按照 T-appendix.jupyter-installation-and-setup.ipynb，安装jupyter lab
遇到什么问题：
    1.因为之前安装好了Anaconda，所以只是更新或安装了一些库
    2.VSCode安装完，使用快捷键 `⇧⌘p` 呼出 Command Palette,却无法找到python:select interpreter，所以无法设置虚拟环境，于是我就卸载           了。（反正没有它，其他很多编辑器都可以用）
    3.配置jupyter_notebook_config.py文件，前面的"#"要删掉才起作用，"#"在python中是注释。
    c.NotebookApp.notebook_dir = '~/'，报不存在此路径，我设置成''，也就是根目录了。
    c.NotebookApp.default_url = '/tree'，我改为'/lab'，默认使用lab模式，而不是notebook
    4.将 Jupyter lab 配置成系统服务
    ~/Library/LaunchAgents/com.jupyter.lab.plist文件中，
    <string>local.job</string>这个是以后进程现实的名字，改为自己想要的，我改成了com.jupyter.lab方便查找
    <string>/Users/your_username/anaconda3/bin/jupyter</string>，并非仅仅改变your_username为apple就行，因为我是自己早都安装的Anaconda，所以我的目录是根目录(所有大家要注意自己的安装目录)，我写成这样/anaconda3/bin/jupyter。
    我就是因为这个问题，所有 launchctl load xxx.plist 一直启动不起来，
    顺便还百度了一下launchctl命令就是用来让系统加载某个服务，改完jupyter目录后就可以正常启动了。
    launchctl start com.jupyter.lab，启动服务
    5.stylus插件，感觉一般般。刚开始用Chrome，后来用了FireFox，平时不怎么用，所有单独开个Jupyter用。
    6.安装插件，快捷键 ⌘ ,，请注意，这里是Command+逗号，刚开始没注意这个,还以为是普通的断句
    toc插件可以把一个文件的大纲显示出来
    sublime插件就是可以使用一下方便的编辑方式
    7.快捷键挨个试用了一遍，有的还是记不住，以后慢慢使用吧。
    补充的快捷键，那个output-scrolling输出滚动，试了半天，后来发现，输出特别长的时候，就有效果了。
    8.输出所有变量内容，看懂了，没试，需要的时候再试吧。
      魔法函数挺有用的
        
第二天(我阅读本书的时间上并不是连续的，第二天只是说明我第二天阅读这本书，中间几天可能因为一些事并没有读)
    <本书>
    自学能力很重要，我自己也是一点自学能力都没有，阅读本书的时候，也坚持提高自己的英语能力。有一句话让我突然惊醒，"学一件东西不怕晚，因为时间迟早要过去，现在觉得5年之后很远很漫长，但是五年之后回头看，这五年就是转瞬即逝的一瞬间。"
    一定要摆脱，没人教，没人带，没人逼，就彻底没戏的状态。
    自己生活工作学习中遇到的所有一问，书本里应该都有答案，--起码有所参考。
    别怕
    
第三天
    <本书>
    Bool布尔值，与(and)、或(or)、非(not)
    n**0.5,n的1/2次方，相当于根号n
    大学四年，可以说只是认识了"代码"这个工具，并没有好好的学习如何使用它，工作五年时间，可以说只是学会了这个工具，并用它完成了工作上的各种需求，还是需要有思想，能解决问题，这需要慢慢锻炼自己的思想和熟练这门工具。
    函数的相关概念：函数名、参数、返回值、调用
    +、-、*、/、//、%、** —— 它们分别代表加、减、乘、除、商、余、幂。
    
    无论怎样，反正都需要输入输出，无论什么语言，不可能没有布尔运算，不可能没有流程控制，不可能没有函数，只要是高级语言，就都需要编译器。
    
    evaluation 运算
    Control Flow 流程控制

    
第四天
    <InfoQ>
    InfoQ专栏：今天看到了这个社区，并且有月刊《架构师》，决定坚持阅读下去。
    第一期
    一：关于敏捷
    敏捷相关的两本书，作者Bas Vodde，出生于荷兰，对敏捷开发有很丰富的实战经验。
    《Scaling Lean & agile Development-Thinking and Organizational Tools》,这本书的主要内容是怎样在大型产品中使用敏捷开发和精益开发，系统思考等，还有一些具体内容，如跨功能的自组织型团队、特性团队，还有些组织方面的东西，如怎样构建组织结构，管理角色，职业规划等。
    《Particles for Scaling Lean and agile Development》,这本书里会讲，怎么做计划、设计、测试，怎样协作，怎样多点开发，离岸开发，在一个庞大的代码库基础上怎样做持续集成，怎样处理遗留代码，怎样做产品管理等。
    CMMI（Capability Maturity Model Integration，能力成熟度模型集成）包含了产品的开发、维护及服务方面最好的实践做法、覆盖了从开始到交付和维护的整个产品生命周期。
    CMMI关注的是管理和组织，而并不是开发本身。在CMMI的一大堆关键过程域(key process area)中，只有一个和开发有关，大多数CMMI的实施都会带来很大的浪费。
    CMMI和agile在实施上可能并不是完全冲突，但是在价值观上是冲突的，CMMI并没有明确的价值观，但是它注重的是"过程重于人，文档重于可以运行的软件"。它不关心你的源码写的怎么样，团队怎么协作，人员是否合适。
    敏捷(agile)看起来比CMMI更适合产品开发的整个流程，效率，质量会更好。
    敏捷就是，我不要敏捷，我要致力于消除软件开发中的一切浪费。
    
    二：MapReduce
    它最初是由google工程师引入的一种编程模型，旨在提供一种可伸缩的方法来处理大数据集。
    nCluster是aster推出的一个高并行处理(MPP)数据库，
    三：Windows HPC Server 2008
    四：DataNucleus Java持久化平台JPOX
    五：AIcon3：
    开源的ActionScript调试工具，其它一些工具比如 X-Ray 呾 Flex Debugger，他们侧重的方向都不一样。
    六：AJAX Animator
    AJAX Animator 0.2 在八月刜发布。讻开源项目使用了 AJAX 技术，提供宋全标准化癿、 在线癿、卋作癿、基二 Web 癿劢画开发工具包。
    七：2008年9月2日 Google Chrome发布
    
    
    
    <本书>：
    从结构上来看，一切计算机程序，都由且仅由两个最基础的部分构成：运算(Evaluation)、流程控制(Control Flow)
    数据类型
        基本数据类型：
            布尔值(Boolean)
            数字(Numbers):整数(int),浮点数(float),复数(complex numbers)
            字符串(string)
        复杂数据类型：
            (列表)list、(等差数列)range、(元组)tuple、(集合)set、(字典)dictionary、(日期类型)Date Type
    对于值的操作：
        数值操作符:加减乘除商余幂：+、-、*、/、//、%、**
        布尔值操作符:与或非： and、or、not
        逻辑操作符:<（小于）、<=（小于等于）、>（大于）、>=（大于等于）、!=（不等于）、==（等于）
        字符串操作符:
        列表操作符:
            拼接：+ 和 ' '（后者是空格）
            拷贝：*
            逻辑运算：in、 not in；以及， <、<=、>、>=、!=、==
    总的来说，数据类型--其实也是值的类型，对其的操作也就一下两种：
    操作符
        值运算、逻辑运算
    函数
        内建函数、第三方类库/模块中的函数、本身所属类中定义的函数
        
    流程控制：
        if elif else
        for in/else
        continue
        break
        pass
        while
        
第五天：
    <InfoQ>
    测试是有必要的，可以让软件出现更少的技术债，但是要合理遵守规则，必要时可以打破规则。
    
    排序 应该在数据库中还是应用中？
    问:请列出在应用中执行排序要优于在MySQL中排序的原因?
    答:通常来说，执行效率需要考虑 CPU、内存和硬盘等的负载情况，假定 MySQL 服务器和 PHP 的服务器都已经按照最适的方式来配置，那么系统的可伸缩性(Scalability)和 用户感知性能(User- perceived Performance)是我从追求的主要目标。在实际运行中，MySQL中数据往往以 HASHtables、BTREE 等方式存贮于内存，操作速度很快;同时INDEX已经进行了一些预排序;很多应用中，MySQL排序是首选。而在应用局(PHP)中排序，也必然在内存中运行，和MySQL 相比具有如下优势:
1. 考虑整个网站的可伸缩性和整体性能，在应用层(PHP)丨排序明显会降低数据库的负载，从而提升整个网站的扩展能力。而数据库的排序，实际上成本是非常高的，消耗内存、 CPU，如果并发的排序很多，DB 很容易到瓶颈。
2. 如果在应用层(PHP)和 MySQL 之间还存在数据中间层，合理利用的话，PHP 会有更好的收益。
3. PHP 在内存中的数据结构专门针对具体应用来设计，比数据库更为简洁、高效;
4. PHP 不用考虑数据灾难恢复问题，可以减少这部分的操作损耗;
5. PHP 不存在表得锁定问题;
6. MySQL中排序，请求和结果返回还需要通过网络连接来进行，而 PHP中排序之后就可以直接返回了，减少了网络 IO。 
    至二执行速度，差异应该不会很大，除非应用设计有问题，造成大量没必要得网络 IO。另外，应用层要注意 PHP的Cache设置，如果超出会报告内部错误;此时要根据应用做好评估，或者调整Cache。具体选择，将取决于具体的应用。
    问:请提供一些必须在 MySQL中排序的实例?
    答:在 PHP中执行排序更优的情冴实例如下:
1. 数据源不在MySQL中，存在硬盘、内存戒者来自网络的请求等;
2. 数据存在MySQL中，量不大，而且没有相应的索引，此旪把数据取出来用PHP排序更快;
3. 数据源来自多个SQL服务器，此时从多个MySQL中取出数据，然后在PHP中排序更快;
4. 除了MySQL以外，存在其它数据源，比如硬盘、内存或者来自网络的请求等，此时不适合把这些数据存入 MySQL 后再排序。
    必须在MySQL中排序的实例如下:
1. MySQL中已经存在这个排序的索引;
2. MySQL中数据量较大，而结果集需要其中很小的一个子集，比如 1000000 行数据，取 TOP10;
3. 对于一次排序、多次调用的情冴，比如统计聚合的情形，可以提供给不同的服务使用，那么在MySQL中排序是首选的。另外，对于数据深度挖掘，通常做法是在应用层做完排序等复杂操作，把结果存入 MySQL 即可，便于多次使用。
4. 不论数据源来自哪里，当数据量大到一定的规模后，由于占用内存/Cache的关系，不再适合PHP中排序了;此时把数据复制、导入或者存在MySQL，并用INDEX 优化，是优于PHP的。不过，用 Java，甚至 C++来处理这类操作会更好。
    从网站整体考虑，就必须加入人力的成本的考虑。假如网站规模的负载较小，而人力有限(人数和能力都可能有限)，此旪在应用层(PHP)做排序要做不少开发和调试工作，耗费时间，得不偿失;不如在DB中处理，简单的说。对于大规模的网站，电力、服务器的费用很高，在系统架构上精打细算，可以节约大量的费用，是公司持续发展之必要;此时如果能在应用层(PHP)进行排序并满足业务需求，尽量在应用层进行。
    
第六天:
    <InfoQ>
    EDA和SOA都是处理复杂事件处理系统
    《架构师》这个月刊，当前看的是第一期，太早了，应该是2007年发布的，所以打算从最新一期开始看。
    
第七天:
    <InfoQ>
    Java12 最主要的两个新特性，switch Expression，代码更简洁。Shenandoah GC主要目标是99.9%的暂停小于10ms，暂停与堆大小无关等。从原理的角度，其内存结构与G1非常相似，都是将内存划分为类似棋盘的region。整体流程与G1也是比较相似的，最大的区别在于实现类并发的Evacuation环节，引入的Brooks Forwarding Pointer技术使得GC在移动对象时，对象引用依然可以访问。
    MangoDB，2007年诞生，区别于单机架构的传统关系型数据库，一种NoSQL数据库，文档型数据库，以JSON格式存储，可以方便的实现海量数据存储。
    MangoDB自动分片，可以再一个集群的几个分片服务器內自动进行数据的分布和均衡，尽可能的把数据均匀的分布到多个存储节点，为应用开发者提供无缝的体验，对程序无侵入，程序无需知道数据的具体位置。采用分片技术，开发者可以很容易的使用数十甚至数百个节点。
    MangoDB支持存储引擎API并引入WiredTiger存储引擎，此前，MangoDB在存储层使用的是操作系统自带的MMAP API进行数据罗盘持久化工作。这使得早期将注意力集中在MangoDB的API、查询、索引计划、数据同步等上层逻辑。引入WiredTiger，解决了之前在大量写入下的性能瓶颈，性能提升了7-10倍。
    MangoDB支持Join，操作符：$lookup，意味着开始支持关系型数据库的核心功能：关联。从3.2开始，在程序中可以一次同时查询多个MangoDB的集合(表)，不用像以前那样，需要在代码中发起多个数据库查询，然后在内存中进行手工关联。
    MangoDB 2017年10月 成功上市纳斯达克，一年后，其市值比其他两家以Hadoop产品为主要业务的大数据科技公司还高。这是因为基于Hadoop产品的目标场景是大数据分析，首先用大量低成本存储聚集所有企业内外部数据，然后用MapReduce技术来对客户进行画像，贴标，或者制作一些统计报表。虽然这些场景确有价值，较之于MangoDB驱动的操作场景，如新型手机应用，游戏，物联网，数字化银行等，无疑MangoDB支撑的是直接面向客户的，更加有业务价值的应用。
    MangoDB赎金事件，为了最大程度上方便程序员快速开发应用，默认方式下不需要设置用户名密码登录。这样一来，很多粗心的程序员，特别是创业公司，往往在系统正式上线的时候也没有启用鉴权。
    MangoDB 2018年6月，推出4.0版本，支持ACID多行多表强事务。之前对事务的支持仅限于单文档內。多文档强事务机制，可以更好的解决多个步骤的原子性，还有出错情况下的回滚机制。
    SSPL开源协议，与之前的AGPL开源协议相比，是一个补充。AGPL协议规定，只要你在使用MangoDB的时候不修改源码，就没有影响。但凡修改了源码，就必须对外公布你的改动及相关联的软件。但是协议有些地方比较模糊，导致很多云厂商并没有按照规则进行开源。所以SSPL协议进行了补充，对云厂商的影响比较大，要么进行商业合作，要么只能开源其所有云管理解决方案。Redis和kafka也都在类似背景下作过开源协议修改。
    MongoDB的成功也源于其开源社区的成功。
    未来规划及展望：
    1.坚持开源和商业化两条腿走路的策略
    2.加注云数据库
    3.补足分析型的短板
    没有一个技术是完美的，MangoDB的核心竞争力在：
    1.基于JSON的数据模型最接近开发者的面向对象的设计思维；
    2.灵活动态的模型意味着在需求多变的时候极大简化数据库设计流程；
    3.自动分片、多节点自动同步和跨中心能力支持各种现代化复杂部署需求。
    
    微服务
    微服务架构模型:
        1.整洁架构(洋葱架构)，领域模型，领域服务，应用服务，界面和基础设施，分层。
        2.六边形架构(端口适配器架构)，内部业务逻辑与外部资源完全隔离，仅通过适配器进行交互。
        3.CQRS(命令与查询职责分离)，就是读写分离，主要为了提高查询性能。
        4.领域驱动设计分层架构(DDD Domain-Driven Design)，坚持层间的耦合关系。设计程序时，应先划分出可能得层次，以及此层次提供的接口和需要的接口。设计某层时，应尽量保持层间的隔离，仅使用下层提供的接口。
    中台和微服务设计的关键在于合理的分层和领域模型的设计。  

第八天
    <InfoQ>
    数据中台
    数据仓库，具有历史性，其中存储的数据大多是结构化数据，这些数据并非企业全量数据，而是根据需求针对性抽取的，因此数据仓库对于业务的价值是各种各样的报表，但这些报表又无法实时产生。数据仓库报表虽然能够提供部分业务价值，但不能直接影响业务。
    数据平台，是为了解决数据仓库不能处理非结构化数据和报表开发周期长的问题，所以先撇开业务需求、把企业所有的数据都抽取出来放到一起，成为一个大的数据集，其中有结构化数据、非结构化数据等。当业务方有需求的时候，再把他们需要的若干个小数据集单独提取出来，以数据集的形式提供给数据应用。
    数据中台，是在数据仓库和数据平台的都基础上，将数据产生为一个个的数据API服务，以更高效的方式提供给业务。
    数据中台是更贴近业务的，需要从业务的角度出发去分析数据，提供服务。
    
    大前端
    React/Vue/Angular，三足鼎立。
    但是最新发布的React v16,Vue3.0，前端三大框架已趋于平稳，标准化，向 Web Components 看齐。
    小程序/PWA，都是应用层封装。多端对齐，并重用户体验。应用层面开始进入过渡封装周边的阶段，很多细节都会埋在框架里
    PWA 平稳发展，兼容 4/5 浏览器，workbox 3 进一步简化开发，另外PWA 桌面版已经开始兴起，未来会更多。
    多端受到重视，不再只是 all in mobile
    WebPack
    TypeScript是JavaScript的超级，具有面向对象的设计能力。TypeScript 落地很好，包容性更好:React 对 .tsx 支持非常好，Vue 从v2.5.0 之后对 ts 支持就非常好，Node.js(尤其是 Egg.js、midway)对 ts 支持也非常好。
    WebAssembly，是一种新的字节码格式。浏览器嵌入其vm，可以提高浏览器的性能。WebAssembly 让更多语言可以运行在浏览器上，AutoCAD 的 web 版是非常好的例子。
    移动端，flutter，RN，Weex。强运营背景下，移动端以前端开发为主，已成定局。Flutter 局势暂不好说，还在观望中(主要是不喜欢 Dart)。
    终上所述，未来浏览器会越来越重要，Web Os 的概念正在慢慢落地。 另外三大框架趋于稳定，写法上也越来越像，学习成本是降低的。但周边 应用层面的封装还会是爆发式增长，更多复杂的细节会被包装到应用框架 里，可能还有很多不一样的开发方式需要大家熟悉。
    对于开发者而言，唯一不变的就是学习能力。掌握了学习能力就能够 应对这些趋势变化，无论是在三大框架混战时代，还是后面周边封装时代 都能很开心的“折腾”。哪怕有一天 AI 真的能够替人写代码，能应变的人 自然也是不怕的。
    
第九天
    <InfoQ>
    实时计算，从Storm到JStorm，Spark Streaming和最近兴起的Flink。
    运满满运营平台的架构升级之路
    运营平台的发展，数字化、智能化。
    业务系统，平台化/中台化
    管理方面，团队的自管理型，发展为自规划团队，最后自治理型团队。并实行"传带帮"持续提升团队成员能力。
    
第十天
    <关于考研>：
    今天上午查了一些关于在职研究生的东西，非全日制研究生，和全日制相比，含金量会低一些，但是现在也在越来越统一。想进修软件工程或者类似专业，利用周末和假期，虽说在一个企业里不是很重视学历，但是作为敲门砖，还是有一定的作用，而且想真的学到一些东西，并对自己学习的东西有一个认可。
    
    <InfoQ>
    做微服务？还是先构建一个单体吧！
    在企业开发人员不多的情况(不到100人)，正确构建的单体系统要优于构建基于微服务的系统，有了一个结构良好的单体之后，必要的时候也可以很容易的把服务迁移出来。
    向微服务转移的常见原因是需要扩展。另一个原因是团队可以自由选择喜欢的开发环境和技术堆栈。但是这样可以就意味着一家公司必须维护几个不同的环境，代价高昂。
    单体通常易于部署和运行，它的体系结构适合许多应用程序。例如某个地方出现故障，那么整个应用都会出现故障，这样我们就知道出问题了。大多数时候，我们知道如何修复它，并快速的重新部署。它很健壮，通常经得起时间的考验。我们中许多人应该都在维护一个 10 年前构建并仍在运行的单体解决方案。而他遇到的几个微服务解决方案在构建后的三年内相当脆弱，不得不进行重构。
    大多数人觉得单体不好维护，其实都是因为设计的不好。一个好的单体设计应该像筒仓一样，每个逻辑的功能部分都包含一个入口点和输出，不与其他筒仓共享任何数据和逻辑。这样设计，当有扩展需求时，可以很容易的迁移到单独的服务中。
    
    <本书>
    函数，是可被调用的完整程序，包含输入，处理，输出。
    输入->参数：位置参数(a)，可选位置参数(a[, b])，可接收多值的位置参数(a, *b)，关键词参数(a='a')。
    输出，每个函数都有返回值，即使内部不指定输出，那么也会输出一个None。
    
    字符串 的各种内建函数和操作，精度损耗问题引起的浮点数多次运算后的误差。

第十一天
    <本书>
    列表 [] 查找内建函数，有些定义的实现为pass，它的具体实现是c，在https://github.com/python/cpython的objects中查找相关源码。
    元组 () 不可变，相对于list占用更小的内存。
    集合 {} 无重复元素，无序，frozen set 是不可变的，创建的时候是 set(), a={}是创建一个字典。
        操作：|并 ，&交，-差，^对称差集(有且仅有其一)，对应的方法 union(),intersection(),difference(),symmetric_difference()
    字典 {"a", 1}, 映射关系
    
    迭代用 for a in range(10)，同时想获取索引用 for i,a in enumerate(range(10)),迭代前排序 先sort或reversed,多容器迭代 zip() 最好保证多容器长度相等，迭代字典 for k,v in dict.items() 或 for k in dict: dict[k]
        
    File，文件
    
第十二天
    <本书>
    "过早引用"，在生活中，有很多知识是自己或别人提前已经理解的，然后我们突然第一次接触到这样的概念时，是一脸懵逼的。所以我们要克服过早引用的东西，就需要反复理解，就跟读书一样，书读百遍，其义自见。敲代码也一样，敲的多了也就明白了。对于不理解的概念，就强行先通读一遍，然后查找相关文献后，再读一遍。
    自学能力，就是要克服懒，反复的总结、归纳、整理、组织。
    
    python官方文档本地化，转化为各种类型的文档，便于查阅。
    
    学、练、用、造。投入足够的"成本"和"预算"在学习新事物上，才会有效果，否则很容易放弃。就是要有耐心，学习这件事，和天份没什么关系。
    刻意练习，认识到自己的不足，刻意思考自己哪里有缺陷，然后刻意练习，直到熟能生巧。
    
第十三天
    <Flutter>
    由于公司要开始做新项目，想着用一下新技术，感觉现在Flutter很火，就查阅了一些资料，跟着官网安装环境，开发Demo。
    语言方面，Dart也是面向对象语言，它的语言特性更简洁易懂，但是也是有一定的学习成本，你要重新学习了解一套完整的语言。Flutter跨平台，一套代码多端可以使用，很方便快捷。整体感觉开发的节奏快了很多，还有Hot Reload技术所见即所得，省去了等待长时间的编译打包的过程。
    但是与Android和IOS移动端Native代码相比，性能上虽然说几乎能媲美，但是我还是有一定差距，起码一个简单的界面和Native还是能感觉到区别。而且会加大安装包的体积，因为Flutter为了体验一致性，提供了一套控件，并且做了相关的桥接，本身库的体积就会大，代码不是编译成本地代码，而是封装到了so里，通过DartVM解析成字节码运行，一些需要Android/IOS的特性会通过桥接的库通信，使用的是自己的图形渲染(skia)、文本渲染(txtlib)等一套机制。说是通过针对性优化，性能也和原生差不多了，但肯定永远达不到原生的性能。代码书写方面，界面都是手写，而且嵌套会很严重，更类似于游戏开发引擎开发界面，游戏引擎现在也在尽量图xml化界面，感觉这样更优。与Android/IOS对比，那种xml渲染界面的机制感觉结构上更清晰。界面与逻辑分离。
    总之用了一下，做了两个demo，感觉流畅性一般，而且界面绘制需要很长时间去习惯。可以搭配native做一些界面快速开发，类似web技术，还是以Native为主。
    
第十四天
    <本书>
    参数、函数、递归，关于函数的一系列说明。函数的文档编写规范，模块，每个模块的导入，使用，查看。各种异常，以及异常的捕获，在写程序的时候考虑各种边界情况，自己写测试用例，让程序更健壮。单独执行py文件，添加main()方法，使得文件里的内容在导入时不被执行，而在命令行中单独运行时可以执行。
    MoSCoW 方法论：Must have、Should have、Could have、won't have'，做一个东西的时候，进行拆分，按照级别先做最重要的，然后一点点完善。
    关于自学
    可以思考哪儿需要刻意练习，不断锻炼自己的思考方式，自学能力强的人，善于发现问题，解决问题，获得知识。
    自学，就是反复读，反复总结归纳，最终融汇贯通。
    
    第二章结束，第三章
    OOP，类，对象，类对象与实例对象的区别。继承、封装、作用域。
    
第十五天
    <本书>
    迭代器Iterator 可被迭代的对象Iterable, 进行iter()方法后就生成了迭代器，可以迭代其中的内容
    生成器Generator 函数內使用率yield关键字，可用于for、while，使用next()获取下一个值，如果没有下一个内容会报StopIteration错误
    生成器表达式(生成式) ()生成的是Iterator，[]生成的是列表，{}生成的是Set
    装饰器Decorator 给一个函数上 @ 另一个函数名，用来扩展当前函数，注解是自下而上一层层调用。可传参 *args，**kwargs
    
    正则表达式(规则表达式)
    原子：本义字符、集合原子、类别原子、边界原子、组合原子
    数量操作符：+ ? * {n,m}
    或操作符：| 优先级低于数量操作符
    匹配并捕获：() 捕获到的值被暂存成带有索引的列表 $1,$2获取，python中用\1,\2获取
    非捕获匹配：(?:)
    控制标记：
    一些常用正则
    
    BNF(Backus-Naur Form) EBNF是python对 巴科斯-诺尔范式的扩展
    
    注意拆解，做一件事之前，先理清思路，把一个大项目拆解成各各小项目，而后逐一攻破，读，练，写，造。
    
    一切都是刚需，只有你掌握了一项技能之后，才知道有没有用，而你掌握之后，肯定都会用到，掌握之前，你根本都没拥有过，更别说用了。想学什么就去学，没时间就挤时间，不要对一项新事物说不。要学就要学官方的，最权威的，这样才能学的全面，要不然就会被网上乱七八糟的教学影响你对它的理解。
    
第十六天
    <本书>
    剩下的都是关于自学的一些讲解，不过说到底，有一点很有必要，那就是不断的总结归纳，能行程文档，作品，去帮助别人。一定要有产出，这样可以让别人很容易的认可你，也可以更好的用作品去沟通交流。
    一定要锻炼自己的写作和演讲能力。
    
    本书完结！开启自己的自学之路，我从小也是自己觉得有天份的人，可能和我父母经常夸我有关，好处就是我对数学越来越感兴趣，会主动的去做题，遇到问题会用数学解决，但是也造成了一个浮躁的我，小学之后，迷恋游戏，于是花更多的时间在游戏上，而学习呢，因为有天份，所以草草了事，以至于那么多年来，养成了一个习惯，快速入门，但却没有深钻，无法精通。即使我现在已经认识到这个严重的问题，但是我依然很难改正自己，学习时候还是很难的钻进去，以遇到问题，短时间解决不了就会头疼，然后就放弃了，就这样吧，反正能用。而且从小家里比较穷，而我爱玩游戏，所以有点钱就买游戏相关的东西了，对于买书...基本上一本没买过，所以也就没有养成阅读的习惯，现在读书很慢，也很苦恼，一看书就困。可以说我的自学能力就是0，不至于是负数，因为我还是喜欢学习新事物新东西，但是就是必须要有人教，否则我自己很难去钻研。现在，无论是什么，我都刻意的去坚持看完，一本书，哪怕是一篇文章，抓取重点，刻意的去总结，把自己读完的感想记录下来。开始一个自己的项目，尽力完成，成为一个作品，发布到Github上，这个过程中，总结问题，记录成博客。